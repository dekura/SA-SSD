'''
@Author: Guojin Chen
@Date: 2020-06-20 10:15:20
LastEditTime: 2021-01-12 16:15:30
@Contact: cgjhaha@qq.com
@Description: transfer the polygons to the velodyne, the split window version
'''
import re
import math
import numpy as np
from .consts import *
'''
@description: transfer the polygons to the velodyne
@param {type}
    args argparse.args
    polys polysets
@return:
    save the velodyne.

example of velodyne:
31.706 0.053 1.281 0.22
31.952 0.154 1.29 0.19
32.167 0.206 1.297 0.28
32.316 0.309 1.302 0.26
32.745 0.416 1.316 0.21
'''



def _ck_vertical(start, end):
    if start[0] == end[0]:
        return True
    else:
        return False

'''
@input: start, end
@output: a set of points
'''
def se2vels(s, e):
    # print('s:',s)
    # print('e:',e)
    vels = np.array([])
    for z_i in [0.1]:
        if _ck_vertical(s, e):
            big = max(s[1], e[1])
            small = min(s[1], e[1])
            x = np.arange(small, big, STEP)
            # print('y:', y)
            y = np.linspace(s[0], e[0], x.shape[0])
            # print('x:', x)
            z = np.zeros(x.shape[0])
            # flip
            y = -y
            # print('z:', z)
            z[:] = z_i
            # alpha = np.random.rand(y.shape[0])
        else:
            big = max(s[0], e[0])
            small = min(s[0], e[0])
            y = np.arange(small, big, STEP)
            # print('x:', x)
            x = np.linspace(s[1], e[1], y.shape[0])
            z = np.zeros(y.shape[0])
            # flip
            y = -y
            z[:] = z_i
        alpha = np.random.rand(x.shape[0])
        vel = np.row_stack((x, y, z, alpha))
        vel = vel.T
        # print('vel: \n', vel)
        if vels.shape[0] > 0:
            vels = np.concatenate((vels, vel), axis=0)
        else:
            vels = vel
    # print(vels)
    return vels



'''
polys: [
    points: [x, y]
    ...
]
'''
def _polys2vels(polys):
    vels = np.array([])
    # print(polys)
    for i in range(len(polys) - 1):
        # if i>1:
            # break
        start = polys[i]
        end = polys[i+1]
        if vels.shape[0] > 0:
            vels = np.concatenate((vels, se2vels(start, end)), axis=0)
        else:
            vels = se2vels(start, end)
    # add the end to start
    start = polys[len(polys) - 1]
    end = polys[0]
    vels = np.concatenate((vels, se2vels(start, end)), axis=0)
    return vels





'''
here the polysets are generated by the polygons from the base gds wire
polysets: [
    polys:[],
    polys: ...
]
'''
def polys2vels(polysets):
    velsets = np.array([])
    for polys in polysets:
        vels = _polys2vels(polys)
        if velsets.shape[0] > 0:
            velsets = np.concatenate((velsets, vels))
        else:
            velsets = vels
        # break
    return velsets


def check_in_poly(vel, poly):
    # print(poly)
    y, x, _, _ = vel
    # y = -y
    x = -x
    # print('x: ', x)
    # print('y: ', y)
    # x_min = poly[0][0]
    x_min = min(poly[0][0], poly[1][0])
    # print(x_min)
    # print('x min ', x_min)
    # x_max = poly[2][0]
    x_max = max(poly[0][0], poly[1][0])
    # print(x_max)
    # print('x max ', x_max)
    # y_min = poly[0][1]
    y_min = min(poly[0][1], poly[2][1])
    # y_max = poly[2][1]
    y_max = max(poly[0][1], poly[2][1])
    # print(x, y)
    if x >= x_min and x<=x_max and y>=y_min and y<=y_max:
        return True
    else:
        return False

'''
check whether the vel in any of the hsd polys
return the poly_number
if -1, means not in any polys
else, in some of the polys
'''
def check_vel_in_hsd_polys(vel, hsd_polys):
    in_poly = -1
    # print(hsd_polys[0].polygons)
    for num, poly in enumerate(hsd_polys):
        in_poly_bool = check_in_poly(vel, poly)
        if in_poly_bool:
            in_poly = num
            return in_poly
    return in_poly


'''
input:
    vel: x, y, z, t
output:
    vel plus: x, y, [z...], t
'''
def plus_vel_height(vel):
    vel_plus = np.array([])
    for z_i in np.arange(HEIGHT_START, HEIGHT_END, HEIGHT_STEP):
        tmp = [vel[0], vel[1], z_i, np.random.rand()]
        if vel_plus.shape[0] == 0:
            vel_plus = np.array([tmp])
            # print(vel_plus.shape)
        else:
            # vel_plus = np.append(vel_plus, tmp)
            # print(vel_plus.shape)
            vel_plus = np.concatenate((vel_plus, np.array([tmp])))
    return vel_plus





'''
if vel.x, vel.y in hsd_polys:
    add the vel's height
return vel_plus
'''
def add_vel_height(vel, hsd_polys):
    in_poly_num = check_vel_in_hsd_polys(vel, hsd_polys)
    if in_poly_num > -1:
        vel_plus = plus_vel_height(vel)
        return vel_plus, in_poly_num
    else:
        return None

def init_hsd_labels(hsd_poly_num):
    hsd_labels = {}
    for i in range(hsd_poly_num):
        hsd_labels['{}'.format(i)] = [[float('inf'), float('inf')], [float('-inf'), float('-inf')]]
    return hsd_labels


def update_hsd_labels(vel, in_poly_num, hsd_labels):
    x, y, _, _ = vel
    hsd_label = hsd_labels['{}'.format(in_poly_num)]
    ## update ll
    hsd_label[0][0] = min(x, hsd_label[0][0])
    hsd_label[0][1] = min(y, hsd_label[0][1])

    ## update ur
    hsd_label[1][0] = max(x, hsd_label[1][0])
    hsd_label[1][1] = max(y, hsd_label[1][1])


def hsd_labels_rm_inf(hsd_labels):
    for key in list(hsd_labels.keys()):
        if math.isinf(hsd_labels[key][0][0]):
            print('hsd_labels[{}] is inf : {}'.format(key, hsd_labels[key]))
            hsd_labels.pop(key)
    return hsd_labels


'''
Here we transfer the hotspots polygons to the velsets
Note that, the gds polys in the hotspots polygons, will get 1.0 height

wire_vels
    x, y, z, t

for each hsd_poly, save the ll and the ur

hsd_labels: {
    'in_poly_num': [ll:[x,y], ur:[x,y]]
}
'''
def hsd_polys2vels(wire_in_hsd, wire_vels):
    hsd_velsets = np.array([])
    for vel in wire_vels:
        vel_plus = add_vel_height(vel, wire_in_hsd)
        if vel_plus is not None:
            vel_plus, in_poly_num = vel_plus
            if hsd_velsets.shape[0] == 0:
                hsd_velsets = vel_plus
            else:
                hsd_velsets = np.concatenate((hsd_velsets,vel_plus))
    return hsd_velsets



def save_vels(velsets, gds_name, args):
    vel_num = re.findall(r"\d+", gds_name)[0]
    vel_name = '{:06d}.bin'.format(int(vel_num))
    vel_path = args.kitti_vel_dir / vel_name

    txt_name = '{:06d}.txt'.format(int(vel_num))
    txt_path = args.kitti_txt_dir / txt_name
    velsets[:, 0] = velsets[:, 0]/SCALE_DOWN
    velsets[:, 1] = velsets[:, 1]/SCALE_DOWN
    velsets = velsets.astype(np.float32)
    velsets.tofile(vel_path)
    np.savetxt(txt_path, velsets, fmt='%.3f')

def label2wh(label):
    width = (label[1][0] - label[0][0])/SCALE_DOWN
    length = (label[1][1] - label[0][1])/SCALE_DOWN
    if width < 0.05:
        return None
    else:
        return width, length

def label2str(label, cx_min, cx_max):
    width = (label[1][0] - label[0][0])/SCALE_DOWN
    length = (label[1][1] - label[0][1])/SCALE_DOWN
    if width < 0.05:
        return None, None
    # print('width = ', width)
    # print('height = ', length)
    cx = (label[0][0] + label[1][0])/(2*SCALE_DOWN)
    cy = (label[0][1] + label[1][1])/(2*SCALE_DOWN)
    # print('cx : ', cx)
    # print('cy : ', cy)
    # cx = cx - width/2 - 0.03
    # cx = cx - 0.35
    # c
    # cy is the smaller one
    cy = cy - 0.35
    # -cy determins the height
    # the closer, -0.1, further, 0.6
    # print('cy_max: ',cy_max)
    # print('cy_min: ',cy_min)
    # cz = -0.15 + 0.1 * ((cy - cy_min) /(cy_max - cy_min))
    cz = -0.1  -0.35 * ((cx - cx_min) / (cx_max - cx_min))
    # print('cz: ', cz)

    label_str = 'Car 0.00 0 0.0 960.00 150.00 1200.00 200.00 0.9 {:.2f} {:.2f} {:.2f} {:.2f} {:.2f} 1.57\n'.format(width, length, cx, cz, cy)



    return label_str

'''
get label y min and max
'''
def get_label_ymm(gds_bbox):
    # print('gds bbox: ', gds_bbox)
    # cy_max = gds_bbox[1][1]
    cx_min = gds_bbox[0][0]/SCALE_DOWN
    cx_max = gds_bbox[1][0]/SCALE_DOWN
    return cx_min, cx_max




def save_labels(hsd_labels, gds_bbox, gds_name, args):
    label_num = re.findall(r"\d+", gds_name)[0]
    label_name = '{:06d}.txt'.format(int(label_num))
    label_path = args.kitti_label_dir / label_name
    # cy_min, cy_max = get_label_ymm(hsd_labels)
    cx_min, cx_max = get_label_ymm(gds_bbox)
    saved_count = 0
    sum_w, sum_h = 0,0
    with open(str(label_path), 'w') as f:
        for i, label in enumerate(hsd_labels):
            label_str = label2str(label, cx_min, cx_max)
            w, h = label2wh(label)
            if label_str is not None:
                f.writelines(label_str)
                saved_count += 1
                sum_w += w
                sum_h += h
    print('save labels num: {}'.format(saved_count))
    return sum_w, sum_h, saved_count